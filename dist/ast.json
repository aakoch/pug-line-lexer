{
  "lex": {
    "rules": [
      [
        [
          "INITIAL"
        ],
        "#\\[{tag}",
        "']'\n                                          return 'TAG'"
      ],
      [
        [
          "INITIAL"
        ],
        "{keyword}",
        "this.pushState('AFTER_KEYWORD');\n                                          return 'KEYWORD';"
      ],
      [
        [
          "INITIAL"
        ],
        "{tag}",
        "this.pushState('AFTER_TAG_NAME');\n                                          return 'TAG';"
      ],
      [
        [
          "INITIAL"
        ],
        "(script|style)",
        "if (TEXT_TAGS_ALLOW_SUB_TAGS) {\n  this.pushState('AFTER_TAG_NAME');\n                                          return 'TAG';\n}\nelse {\n  this.pushState('AFTER_TEXT_TAG_NAME');\n                                          return 'TEXT_TAG';\n}"
      ],
      [
        [
          "INITIAL"
        ],
        "{tag_id}",
        "this.pushState('AFTER_TAG_NAME');\n  yytext = yytext.substring(1);\n                                          return 'TAG_ID';"
      ],
      [
        [
          "INITIAL"
        ],
        "{mixin_call}",
        "yytext = yytext.substring(1);\n  this.pushState('MIXIN_CALL_START');\n                                          return 'MIXIN_CALL';"
      ],
      [
        [
          "INITIAL"
        ],
        "\\}",
        "this.pushState('AFTER_KEYWORD');\n                                          return 'RCURLY';"
      ],
      [
        [
          "INITIAL"
        ],
        "{conditional}",
        "this.pushState('COND_START');\n  if (yytext.startsWith('-')) {\n    yytext = yytext.substring(1);\n  }\n                                          return 'CONDITIONAL';"
      ],
      [
        [
          "COND_START"
        ],
        "\\(",
        "')'\n  this.pushState('COND_START');\n                                          return 'LPAREN';"
      ],
      [
        [
          "COND_START"
        ],
        ".+\\)",
        "this.popState();\n  yytext = yytext.substring(0, yytext.length - 1)\n                                          return ['RPAREN', 'CONDITION'];"
      ],
      [
        [
          "INITIAL"
        ],
        "-",
        "this.pushState('CODE_START');\n                                          return 'CODE_START';"
      ],
      [
        [
          "INITIAL"
        ],
        "{classname}",
        "// debug('<INITIAL>{classname}')\n  this.pushState('AFTER_TAG_NAME');\n  yytext = yytext.substring(1);\n                                          return 'CLASSNAME';"
      ],
      [
        [
          "INITIAL"
        ],
        "\\/\\/",
        "this.pushState('TEXT');\n                                          return 'COMMENT';"
      ],
      [
        [
          "INITIAL"
        ],
        "<[A-Z_]+>",
        "this.pushState(yytext.substring(1, yytext.length - 1));"
      ],
      [
        [
          "INITIAL",
          "TEXT"
        ],
        "\\| ",
        "this.pushState('TEXT');\n                                           return 'PIPE';"
      ],
      [
        [
          "INITIAL"
        ],
        "\\|\\.",
        "this.pushState('TEXT');\n  this.unput('.');"
      ],
      [
        [
          "INITIAL"
        ],
        "\\|$",
        "this.pushState('TEXT');\n                                           return 'SPACE'; // only because it is an empty object"
      ],
      [
        [
          "INITIAL",
          "AFTER_TAG_NAME",
          "ATTRS_END"
        ],
        "&attributes\\([^\\)]+\\)",
        "debug(\"'&attributes('[^\\)]+')'\")\n                                          return 'AT_ATTRS'"
      ],
      [
        [
          "INITIAL"
        ],
        "{interpolation}",
        "debug('{interpolation}')\n  this.pushState('AFTER_TAG_NAME');\n                                          return 'INTERPOLATION';"
      ],
      [
        [
          "INITIAL"
        ],
        "{interpolation_start}",
        "debug('{interpolation_start}')\n  this.pushState('INTERPOLATION_START');\n                                          return 'INTERPOLATION_START';"
      ],
      [
        [
          "AFTER_TAG_NAME"
        ],
        "= ",
        "this.popState();\n  this.pushState('ASSIGNMENT_VALUE');\n                                          return 'ASSIGNMENT';"
      ],
      [
        [
          "AFTER_TAG_NAME",
          "AFTER_ATTRS"
        ],
        ": ",
        "this.popState();\n                                          return 'NESTED_TAG_START';"
      ],
      [
        [
          "AFTER_KEYWORD"
        ],
        "{filter}",
        "yytext = yytext.substring(1)\n                                          return 'FILTER';"
      ],
      [
        [
          "AFTER_TAG_NAME",
          "AFTER_TEXT_TAG_NAME"
        ],
        "\\(",
        "')' // hack for syntax\n  debug(`<AFTER_TAG_NAME,AFTER_TEXT_TAG_NAME>'('`)\n  this.pushState('ATTRS_STARTED');\n                                          return 'LPAREN';"
      ],
      [
        [
          "ATTRS_END"
        ],
        "\\)",
        "return 'RPAREN';"
      ],
      [
        [
          "MIXIN_PARAMS_END"
        ],
        "\\)",
        "// this.popState() // for inline blocks after mixin calls\n                                          return 'RPAREN';"
      ],
      [
        [
          "INITIAL",
          "ATTRS_END"
        ],
        "{classname}",
        "debug('<INITIAL>{classname}')\n  this.pushState('AFTER_TAG_NAME');\n  yytext = yytext.substring(1);\n                                          return 'CLASSNAME';"
      ],
      [
        [
          "ATTRS_STARTED"
        ],
        "(\\(.+|.+\\().+",
        "'))'\n  debug('15 yytext=', yytext)\n  debug('15 this.matches=', this.matches)\n\n  const stack = []\n  let i = 0\n  for(; i < yytext.length; i++) {\n    // debug('yytext[i]=', yytext[i])\n    if (/[\\)\\]}]/.test(yytext[i])) {\n      debug('match')\n      debug('stack.peek()=', stack.peek())\n      if (stack.length == 0 || stack.pop() != yytext[i]) {\n        debug('stack.length=', stack.length)\n        break;\n      }\n      // else if () {\n      // }\n    }\n    else {\n      switch (yytext[i]) {\n        case '(':\n          stack.push(')')\n          break;\n        case '[':\n          stack.push(']')\n          break;\n        case '{':\n          stack.push('}')\n          break;\n      }\n      // else if () {\n      // }\n    }\n  }\n\n  this.unput(yytext.substring(i))\n  yytext = yytext.substring(0, i)\n  debug('15 yytext=', yytext)\n\n  this.popState()\n  this.pushState('ATTRS_END')\n                                          return 'ATTR_TEXT';"
      ],
      [
        [
          "ATTRS_STARTED"
        ],
        "([^\\)]+)(\\))(?!\\s*\\..+\\))",
        "this.popState()\n  this.pushState('ATTRS_END')\n  debug('20 this.matches=', this.matches)\n  debug('20 this.matches.length=', this.matches.length)\n  debug('20 yytext=', yytext)\n  try {\n    this.unput(')');\n    if (this.matches.length > 1) {    \n      yytext = this.matches[1]\n      // if (yytext.startsWith(')')) {\n      //   yytext = yytext.substring(1)\n      // }\n    }\n  }\n  catch (e) {\n    console.error(e)\n  }\n  lparenOpen = false\n  debug('20 yytext=', yytext)\n                                          return 'ATTR_TEXT';"
      ],
      [
        [
          "ATTRS_STARTED"
        ],
        "(.+)\\)\\s*$",
        "this.popState()\n  debug('30 this.matches=', this.matches)\n  debug('30 this.matches.length=', this.matches.length)\n  debug('30 yytext=', yytext)\n  try {\n    if (this.matches.length > 1) {    \n      yytext = this.matches[1]\n    }\n  }\n  catch (e) {\n    console.error(e)\n  }\n  lparenOpen = false\n  debug('30 yytext=', yytext)\n                                          return ['RPAREN', 'ATTR_TEXT'];"
      ],
      [
        [
          "ATTRS_STARTED"
        ],
        "(.+)\\)\\.?\\s*(.+)$",
        "this.popState()\n  this.pushState('ATTRS_END')\n  debug('40 this.matches=', this.matches)\n  this.unput(this.matches[2])\n  yytext = yytext.substring(0, yytext.indexOf(this.matches[1]) + this.matches[1].length);\n  debug('40 yytext=', yytext)\n  lparenOpen = false\n                                          return ['RPAREN', 'ATTR_TEXT'];"
      ],
      [
        [
          "ATTRS_STARTED"
        ],
        "(.+)\\.?\\s*$",
        "this.popState()\n  debug('50 this.matches=', this.matches)\n  debug('50 this.matches.length=', this.matches.length)\n  debug('50 yytext=', yytext)\n  try {\n    if (this.matches.length > 1) {    \n      yytext = this.matches[1]\n    }\n  }\n  catch (e) {\n    console.error(e)\n  }\n  debug('50 yytext=', yytext)\n                                          return 'ATTR_TEXT_CONT';"
      ],
      [
        [
          "AFTER_TAG_NAME"
        ],
        "{tag_id}",
        "this.pushState('AFTER_TAG_NAME');\n  yytext = this.matches[1].substring(1)\n                                          return 'TAG_ID';"
      ],
      [
        [
          "AFTER_TAG_NAME"
        ],
        "{classname}",
        "yytext = this.matches[1].substring(1);\n  debug('60 yytext=', yytext)\n                                          return 'CLASSNAME';"
      ],
      [
        [
          "INITIAL"
        ],
        "{space}{2,}",
        "debug('{space}{2,}');\n                                                              return 'SPACE';"
      ],
      [
        [
          "AFTER_TAG_NAME",
          "AFTER_KEYWORD",
          "AFTER_TEXT_TAG_NAME"
        ],
        "{space}{space}",
        "this.pushState('TEXT');\n  debug('space space');\n  this.unput(' ');\n                                                              return 'SPACE';"
      ],
      [
        [
          "AFTER_TAG_NAME",
          "AFTER_KEYWORD",
          "AFTER_TEXT_TAG_NAME"
        ],
        "{space}{classname}",
        "this.pushState('ATTRS_END');\n  yytext = yytext.substring(1);\n                                          return 'TEXT';"
      ],
      [
        [
          "AFTER_TAG_NAME",
          "AFTER_KEYWORD",
          "AFTER_TEXT_TAG_NAME"
        ],
        "{space}",
        "this.pushState('ATTRS_END');\n  debug('<AFTER_TAG_NAME,AFTER_KEYWORD,AFTER_TEXT_TAG_NAME>{space}');\n                                                              return 'SPACE';"
      ],
      [
        [
          "ATTRS_END",
          "MIXIN_PARAMS_END"
        ],
        "{space}",
        "this.pushState('TEXT');\n  debug('<ATTRS_END>{space}');\n                                                              return 'SPACE';"
      ],
      [
        [
          "AFTER_TAG_NAME",
          "AFTER_TEXT_TAG_NAME",
          "ATTRS_END"
        ],
        "\\.\\s*$",
        "return 'DOT_END';"
      ],
      [
        [
          "AFTER_TAG_NAME",
          "AFTER_KEYWORD",
          "AFTER_TEXT_TAG_NAME",
          "NO_MORE_SPACE"
        ],
        ".+",
        "// if (yytext.startsWith(' ') {\n  //   yytext = yytext.substring(1);\n  // }\n  debug('70 yytext=', yytext);\n                                          return 'TEXT';"
      ],
      [
        [
          "ATTRS_END"
        ],
        "={space}",
        "this.popState();\n  this.pushState('ASSIGNMENT_VALUE');\n                                          return 'ASSIGNMENT';"
      ],
      [
        [
          "INITIAL",
          "ATTRS_END"
        ],
        "\\.\\s*$",
        "this.popState();\n                                          return 'DOT_END';"
      ],
      [
        [
          "ASSIGNMENT_VALUE"
        ],
        ".+",
        "this.popState();\n                                          return 'ASSIGNMENT_VALUE';"
      ],
      [
        [
          "ATTRS_END"
        ],
        ".+",
        "// yytext = yytext.substring(1)\n  debug('6 yytext=', yytext)\n                                          return 'TEXT';"
      ],
      [
        [
          "CODE_START",
          "UNBUF_CODE"
        ],
        "{space}",
        "debug('<CODE_START,UNBUF_CODE>{space}');\n                                          return 'SPACE';"
      ],
      [
        [
          "CODE_START",
          "UNBUF_CODE"
        ],
        ".+",
        "return 'CODE';"
      ],
      [
        [
          "MIXIN_CALL_START"
        ],
        "\\(",
        "')'\n  this.popState();\n  this.pushState('MIXIN_PARAMS_STARTED');\n                                          return 'LPAREN';"
      ],
      [
        [
          "MIXIN_CALL_START"
        ],
        "{space}$",
        "this.popState();"
      ],
      [
        [
          "TEXT"
        ],
        ".+",
        "debug('80 yytext=', yytext)\n                                          return 'TEXT';"
      ],
      [
        [
          "MULTI_LINE_ATTRS"
        ],
        ".*\\)",
        "this.popState();\n                                          return 'ATTR_TEXT_END';"
      ],
      [
        [
          "MULTI_LINE_ATTRS"
        ],
        ".+",
        "return 'ATTR_TEXT_CONT';"
      ],
      [
        [
          "MIXIN_PARAMS_STARTED"
        ],
        "(.+)(\\))",
        "this.popState()\n  this.pushState('MIXIN_PARAMS_END')\n  debug('120 this.matches=', this.matches)\n  debug('120 this.matches.length=', this.matches.length)\n  debug('120 yytext=', yytext)\n  try {\n    this.unput(')');\n    if (this.matches.length > 1) {    \n      yytext = this.matches[1]\n      // if (yytext.startsWith(')')) {\n      //   yytext = yytext.substring(1)\n      // }\n    }\n  }\n  catch (e) {\n    console.error(e)\n  }\n  lparenOpen = false\n  debug('120 yytext=', yytext)\n                                          return 'MIXIN_PARAMS';"
      ]
    ],
    "macros": {
      "space": "[ \\u00a0\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u2028\\u2029\\u3000]",
      "tag": "(a|abbr|acronym|address|applet|area|article|aside|audio|b|base|basefont|bdi|bdo|bgsound|big|blink|blockquote|body|br|button|canvas|caption|center|cite|code|col|colgroup|content|data|datalist|dd|del|details|dfn|dialog|dir|div|dl|dt|em|embed|fieldset|figcaption|figure|font|foo|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hgroup|hr|html|i|iframe|image|img|input|ins|kbd|keygen|label|legend|li|link|main|map|mark|marquee|math|menu|menuitem|meta|meter|nav|nobr|noembed|noframes|noscript|object|ol|optgroup|option|output|p|param|picture|plaintext|portal|pre|progress|q|rb|rp|rt|rtc|ruby|s|samp|section|select|shadow|slot|small|source|spacer|span|strike|strong|sub|summary|sup|svg|table|tbody|td|template|textarea|tfoot|th|thead|time|title|tr|track|tt|u|ul|var|video|wbr|xmp)\\b",
      "keyword": "(append|block|case|default|doctype|each|else|extends|for|if|include|mixin|unless|when|while)\\b",
      "filter": ":[a-z0-9-]+\\b",
      "classname": "\\.-?[_a-zA-Z]+[_a-zA-Z0-9-]*",
      "tag_id": "#[a-z0-9-]+",
      "mixin_call": "\\+[a-z]+\\b",
      "conditional": "-?(if|elseif|else)",
      "interpolation_start": "#\\{",
      "interpolation": "#\\{.+\\}"
    },
    "startConditions": {
      "TEXT": 1,
      "TEXT_START": 1,
      "AFTER_TAG_NAME": 1,
      "ATTRS_STARTED": 1,
      "ATTR_TEXT": 1,
      "MIXIN_CALL_START": 1,
      "ATTRS_END": 0,
      "CODE_START": 1,
      "UNBUF_CODE": 1,
      "MULTI_LINE_ATTRS": 1,
      "COMMENT": 1,
      "AFTER_ATTRS": 1,
      "AFTER_TEXT_TAG_NAME": 1,
      "AFTER_KEYWORD": 1,
      "NO_MORE_SPACE": 1,
      "ASSIGNMENT_VALUE": 1,
      "COND_START": 1,
      "INTERPOLATION_START": 1,
      "MIXIN_PARAMS_STARTED": 1
    },
    "codeSections": [],
    "importDecls": [],
    "unknownDecls": [],
    "options": {
      "case-insensitive": true
    }
  },
  "options": {
    "ebnf": true,
    "token-stack": true
  },
  "moduleInclude": " \nvar assert = require(\"assert\");\nvar util = require(\"util\");\nvar utils = require(\"@aakoch/utils\");\nvar _ = require(\"lodash\");\nvar debugFunc = require('debug')\nconst dyp = require('dyp');\nconst parseAttrs = require('../dist/attrs.cjs')\nconst parseInline = require('../dist/inline.cjs')\n\nconst TEXT_TAGS_ALLOW_SUB_TAGS = true\n\nconst debug = debugFunc('pug-line-lexer')\n\nlet tagAlreadyFound = false\nlet obj\nvar lparenOpen = false\nconst keysToMergeText = ['therest']\n\nfunction rank(type1, type2) {\n  if (type2 === 'text') {\n    return type1\n  }\n  else if (type1 === type2) {\n    return type1\n  }\n  // else if (type1 == 'tag' && type2 == 'tag_with_multiline_attrs') {\n  //   return type2\n  // }\n  // else if (type1 == 'tag_with_multiline_attrs' && type2 == 'tag') {\n  //   return type1\n  // }\n  else {\n    return type1.concat(type2)\n  }\n} \n\nfunction merge(obj, src) {\n\n  if (obj == undefined || _.isEmpty(obj)) {\n    debug('empty/undefined obj, returning src')\n    return src\n  }\n  else if (src == undefined || _.isEmpty(src)) {\n    debug('empty/undefined src, returning obj')\n    return obj\n  }\n\n  if (Array.isArray(src) && src.length > 0) {\n    src = src.reduce(merge)\n    debug('src reduced to=', src)\n  }\n\n  debug('merging', obj, src)\n\n  // if (util.isDeepStrictEqual(src, [ { therest: '' } ]))\n  //    return obj\n\n  if (obj.type != 'text' && Object.keys(src).length == 1 && Object.keys(src)[0] == 'children' && src.children.length == 1 && src.children[0].hasOwnProperty('type') && src.children[0].type == 'text') {\n    return Object.assign(obj, { val: src.children[0].val })\n  }\n\n  const ret = _.mergeWith(obj, src, function (objValue, srcValue, key, object, source, stack) {\n    debug('merging', 'inside _mergeWith', key, objValue, srcValue)\n    if (objValue == undefined && srcValue == undefined) {\n       return {}\n    }\n    if (objValue == undefined) {\n       return srcValue\n    }\n    if (srcValue == undefined) {\n       return objValue\n    }\n    if (keysToMergeText.includes(key)) {\n        return objValue + srcValue\n    }\n    else {\n        return rank(objValue, srcValue)\n    }\n  })\n  debug('merging', ' returning', ret)\n  return ret\n  //  return Object.assign(obj, src);\n}\n\nparser.main = function () {\n  \n  tagAlreadyFound = false\n  lparenOpen = false\n\n  function test(input, expected, strict = true ) {\n    tagAlreadyFound = false\n    lparenOpen = false\n    debug(`\\nTesting '${input}'...`)\n    var actual = parser.parse(input)\n    debug(input + ' ==> ', util.inspect(actual))\n    \n    let compareFunc\n    if (strict)\n      compareFunc = assert.deepEqual\n    else \n      compareFunc = dyp\n\n    compareFunc.call({}, actual, expected)\n  }\n\n\ntest(\"a.rho(href='#', class='rho--modifier')\", {\n  attrs: [\n    {\n      name: 'href',\n      val: \"'#'\"\n    },\n    {\n      name: 'class',\n      val: \"'rho--modifier'\"\n    }\n  ],\n  classes: [\n    'rho'\n  ],\n  name: 'a',\n  type: 'tag'\n})\ntest(`div(id=id)&attributes({foo: 'bar', fred: 'bart'})`, {\n  type: 'tag',\n  name: 'div',\n  attrs: [{\n    name: 'id',\n    val: 'id'\n  }, {\n    name: 'foo',\n    val: 'bar'\n  }, {\n    name: 'fred',\n    val: 'bart'\n  }]\n})\n\n// commenting this all out for now while I test pug-attr {\ntest(`a(class=['foo', 'bar', 'baz'])`, { type: 'tag', name: 'a', attrs: [\n    {\n      name: 'class',\n      val: \"['foo', 'bar', 'baz']\"\n    }\n  ] })\n\n// TODO: revisit\ntest(`a.foo(class='bar').baz`, {\n  attrs: [\n    {\n      name: 'class',\n      val: \"'bar'\"\n    }\n  ],\n  classes: [\n    'foo',\n    'baz'\n  ],\n  name: 'a',\n  type: 'tag'\n})\n// How is that ^ different than this?: a(href='/save').button save\n\ntest(`a.foo-bar_baz`, {\n  classes: [\n    'foo-bar_baz'\n  ],\n  name: 'a',\n  type: 'tag'\n})\ntest(`a(class={foo: true, bar: false, baz: true})`, {\n  attrs: [\n    {\n      name: 'class',\n      val: '{foo: true, bar: false, baz: true}'\n    }\n  ],\n  name: 'a',\n  type: 'tag'\n})\n\ntest('span(v-for=\"item in items\" :key=\"item.id\" :value=\"item.name\")', {\n  name: 'span',\n  type: 'tag',\n  attrs: [\n    { name: 'v-for', val: '\"item in items\"' },\n    { name: ':key', val: '\"item.id\"' },\n    { name: ':value', val: '\"item.name\"' }\n  ]\n})\n\ntest('p <strong>strongly worded phrase</strong> that cannot be <em>ignored</em>', {\n  name: 'p',\n  type: 'tag',\n  val: '<strong>strongly worded phrase</strong> that cannot be <em>ignored</em>'\n})\n\n\n// Not sure about this...\ntest('span &boxv;', { type: 'tag', name: 'span', val: '&boxv;'})\n//  {\n//   name: 'span',\n//   type: 'tag',\n//   children: [ { type: 'text', val: '&boxv;' } ]\n// })\n\ntest('include:markdown-it article.md', { type: 'include', val: 'article.md', filter: 'markdown-it' })\ntest('span.hljs-section )', { type: 'tag', name: 'span', classes: ['hljs-section'], val: ')'})\ntest(\"#{'foo'}(bar='baz') /\", {\n  attrs: [\n    {\n      name: 'bar',\n      val: \"'baz'\"\n    }\n  ],\n  name: \"#{'foo'}\",\n  type: 'interpolation',\n  val: '/'\n})\n\ntest('li= item', {\n  assignment: true,\n  assignment_val: 'item',\n  name: 'li',\n  type: 'tag'\n})\n// test('<MULTI_LINE_ATTRS_END>)', {\n//   state: 'MULTI_LINE_ATTRS_END'\n// })\n// test('a(:link=\"goHere\" value=\"static\" :my-value=\"dynamic\" @click=\"onClick()\" :another=\"more\") Click Me!', {})\n\ntest('-var ajax = true', {type: 'code', val: 'var ajax = true', state: 'CODE_START' })\ntest('-if( ajax )', {type: 'conditional', name: 'if', condition: ' ajax '})\ntest('span.font-monospace .htmlnanorc', {\n  type: 'tag', name: 'span', classes: ['font-monospace'], val: '.htmlnanorc'})\n\ntest('.container.post#post-20210905', {\n  type: 'tag',\n  id: 'post-20210905',\n  classes: ['container', 'post']\n})\n\ntest('<UNBUF_CODE>var i', {\n  type: 'code',\n  val: 'var i'\n})\n\ntest('} else {', {\n  type: 'block_end',\n  val: 'else {'\n})\n\ntest(\"+project('Moddable Two (2) Case', 'Needing Documentation ', ['print'])\", { type: 'mixin_call', name: 'project', params: \n    \"'Moddable Two (2) Case', 'Needing Documentation ', ['print']\"\n  })\n\ntest('code(class=\"language-scss\").', {\n  name: 'code',\n  type: 'tag',\n  attrs: [ { name: 'class', val: '\"language-scss\"' } ],\n  state: 'TEXT_START'\n})\n\ntest('p: a(href=\"https://www.thingiverse.com/thing:4578862\") Thingiverse', {\n  name: 'p',\n  type: 'tag',\n  state: 'NESTED',\n  children: [ { name: 'a', type: 'tag', attrs: [{\n          name: 'href',\n          val: '\"https://www.thingiverse.com/thing:4578862\"'\n        }], val: 'Thingiverse' } ]\n})\n\ntest('.project(class= (tags || []).map((tag) => tag.replaceAll(\" \", \"_\")).join(\" \"))', {\n  type: 'tag',\n  classes: [ 'project' ],\n  attrs: [\n    {\n      name: 'class',\n      val: '(tags || []).map((tag) => tag.replaceAll(\" \", \"_\")).join(\" \")'\n    }\n  ]\n})\n\ntest('.status-wrapper Status:', { classes: [ 'status-wrapper' ], type: 'tag', val: 'Status:' })\n\ntest('+sensitive ', {\n  name: 'sensitive',\n  type: 'mixin_call'\n})\n\ntest('a(href=url)= url', {\n  assignment: true,\n  assignment_val: 'url',\n  attrs: [\n    { name: 'href', val: 'url' }\n  ],\n  name: 'a',\n  type: 'tag'\n})\n\n// I'm not supporting this right now\n// test('a(href=\\'/user/\\' + id, class=\\'button\\')', {\n//   attrs: [\n//     \"href='/user/' + id, class='button'\"\n//   ],\n//   name: 'a',\n//   type: 'tag'\n// })\n\ntest('- function answer() { return 42; }', {\n  state: 'CODE_START',\n  type: 'code',\n  val: 'function answer() { return 42; }'\n})\n\n// I'm not supporting this right now\n// test('a(href=\\'/user/\\' + id, class=\\'button\\')', {\n//   attrs: [\n//     \"href='/user/' + id, class='button'\"\n//   ],\n//   name: 'a',\n//   type: 'tag'\n// })\n// test('a(href  =  \\'/user/\\' + id, class  =  \\'button\\')', {\n//   attrs: [\n//     \"href  =  '/user/' + id, class  =  'button'\"\n//   ],\n//   name: 'a',\n//   type: 'tag'\n// })\n\ntest('a(class = [\\'class1\\', \\'class2\\'])',  {\n  name: 'a',\n  type: 'tag',\n  attrs: [ { name: 'class', val: \"['class1', 'class2']\" } ]\n})\ntest('a.tag-class(class = [\\'class1\\', \\'class2\\'])', {\n  attrs: [\n    {\n      name: 'class',\n      val: \"['class1', 'class2']\"\n    }\n  ],\n  classes: [\n    'tag-class'\n  ],\n  name: 'a',\n  type: 'tag'\n})\ntest('a(href=\\'/user/\\' + id class=\\'button\\')',  {\n  name: 'a',\n  type: 'tag',\n  attrs: [\n    { name: 'href', val: \"'/user/' + id\" },\n    { name: 'class', val: \"'button'\" }\n  ]\n})\ntest('a(href  =  \\'/user/\\' + id class  =  \\'button\\')', {\n  name: 'a',\n  type: 'tag',\n  attrs: [\n    { name: 'href', val: \"'/user/' + id\" },\n    { name: 'class', val: \"'button'\" }\n  ]\n})\ntest('meta(key=\\'answer\\' value=answer())', {\n  name: 'meta',\n  type: 'tag',\n  attrs: [\n    { name: 'key', val: \"'answer'\" },\n    { name: 'value', val: 'answer()' }\n  ]\n})\n\ntest('div(id=id)&attributes({foo: \\'bar\\'})', {\n  name: 'div',\n  type: 'tag',\n  attrs: [ { name: 'id', val: 'id' }, { name: 'foo', val: 'bar' } ]\n})\ntest('div(foo=null bar=bar)&attributes({baz: \\'baz\\'})', {\n  name: 'div',\n  type: 'tag',\n  attrs: [\n    { name: 'foo', val: 'null' },\n    { name: 'bar', val: 'bar' },\n    { name: 'baz', val: 'baz' }\n  ]\n})\n\ntest('foo(abc', {type: 'tag', name: 'foo', attrs: [ { name: 'abc' }], state: 'MULTI_LINE_ATTRS'})\ntest('foo(abc,', {type: 'tag', name: 'foo', attrs: [ { name: 'abc' }], state: 'MULTI_LINE_ATTRS'})\ntest('<MULTI_LINE_ATTRS>,def)', { type: 'attr_end', val: ',def)' })\n\ntest('span(', {type: 'tag', name: 'span', state: 'MULTI_LINE_ATTRS'})\ntest('<MULTI_LINE_ATTRS>v-for=\"item in items\"', { type: 'attr_cont', val: 'v-for=\"item in items\"',\n  state: 'MULTI_LINE_ATTRS' })\ntest('<MULTI_LINE_ATTRS>:key=\"item.id\"', {\n  type: 'attr_cont',\n  val: ':key=\"item.id\"',\n  state: 'MULTI_LINE_ATTRS'\n})\ntest('<MULTI_LINE_ATTRS>:value=\"item.name\"', {\n  type: 'attr_cont',\n  val: ':value=\"item.name\"',\n  state: 'MULTI_LINE_ATTRS'\n})\ntest('<MULTI_LINE_ATTRS>)', { type: 'attr_end', val: ')' })\ntest('a(:link=\"goHere\" value=\"static\" :my-value=\"dynamic\" @click=\"onClick()\" :another=\"more\") Click Me!', {\n  name: 'a',\n  type: 'tag',\n  attrs: [\n    { name: ':link', val: '\"goHere\"' },\n    { name: 'value', val: '\"static\"' },\n    { name: ':my-value', val: '\"dynamic\"' },\n    { name: '@click', val: '\"onClick()\"' },\n    { name: ':another', val: '\"more\"' }\n  ],\n  val: 'Click Me!'\n})\n\ntest('foo(data-user=user)', {\n  name: 'foo',\n  type: 'tag',\n  attrs: [ { name: 'data-user', val: 'user' } ]\n})\ntest('foo(data-items=[1,2,3])', {\n  name: 'foo',\n  type: 'tag',\n  attrs: [ { name: 'data-items', val: '[1,2,3]' } ]\n})\ntest('foo(data-username=\\'tobi\\')', {\n  attrs: [ { name: 'data-username', val: \"'tobi'\" } ],\n  name: 'foo',\n  type: 'tag'\n})\ntest('foo(data-escaped={message: \"Let\\'s rock!\"})', {\n  attrs: [\n    { name: 'data-escaped', val: '{message: \"Let\\'s rock!\"}' }\n  ],\n  name: 'foo',\n  type: 'tag'\n})\ntest('foo(data-ampersand={message: \"a quote: &quot; this & that\"})', {\n  attrs: [\n    { name: 'data-ampersand', val: '{message: \"a quote: &quot; this & that\"}' }\n  ],\n  name: 'foo',\n  type: 'tag'\n})\ntest('foo(data-epoc=new Date(0))', {\n  attrs: [\n    { name: 'data-epoc', val: 'new Date(0)' }\n  ],\n  name: 'foo',\n  type: 'tag'\n})\n\n\ntest('+sensitive', {\n  name: 'sensitive',\n  type: 'mixin_call'\n})\n\ntest('html', { type: 'tag', name: 'html' })\ntest('html ', { type: 'tag', name: 'html' }, false)\n\n// test(\"doctype html\", { type: 'doctype', val: 'html' })\ntest('doctype html', { type: 'doctype', val: 'html' })\n\ntest(\"html(lang='en-US')\", {\"type\":\"tag\",\"name\":\"html\",\"attrs\":[{name:\"lang\", val: \"'en-US'\"}]})\n\n// test(\"include something\", { type: 'include_directive', params: 'something' })\ntest('include something', { type: 'include', val: 'something' })\n\n// test(\"block here\", { type: 'directive', name: 'block', params: 'here' })\ntest(\"block here\", { type: 'block', val: 'here' })\n\ntest(\"head\", { type: 'tag', name: 'head' })\ntest(\"meta(charset='UTF-8')\", {\"type\":\"tag\",\"name\":\"meta\",\"attrs\":[{name:\"charset\", val:\"'UTF-8'\"}]})\ntest(\"meta(name='viewport' content='width=device-width')\", { type: 'tag', name: 'meta', attrs: [{name: 'name', val: \"'viewport'\"}, {name: 'content', val: \"'width=device-width'\"}]})\ntest(\"title\", {\"type\":\"tag\",\"name\":\"title\"})\ntest(\"| White-space and character 160 | Adam Koch \", {\"type\":\"text\",\"val\":\"White-space and character 160 | Adam Koch \"})\nif (!TEXT_TAGS_ALLOW_SUB_TAGS)\n  test(\"script(async src=\\\"https://www.googletagmanager.com/gtag/js?id=UA-452464-5\\\")\", {\"type\":\"tag\",\"name\":\"script\",\"attrs\":[\"async src=\\\"https://www.googletagmanager.com/gtag/js?id=UA-452464-5\\\"\"], state: 'TEXT_START'})\ntest(\"script.  \", {\"type\":\"tag\",\"name\":\"script\",\"state\":\"TEXT_START\"})\ntest(\"<TEXT>window.dataLayer = window.dataLayer || [];   \", { type: 'text', val: 'window.dataLayer = window.dataLayer || [];   ' })\ntest(\"<TEXT>gtag('config', 'UA-452464-5');\", {\"type\":\"text\",\"val\":\"gtag('config', 'UA-452464-5');\"})\ntest(\"\", \"\")\nif (!TEXT_TAGS_ALLOW_SUB_TAGS)\n  test(\"script test\", {\"type\":\"tag\",\"name\":\"script\",\"state\":\"TEXT_START\",\"val\":\"test\"})\ntest(\".classname\", { type: 'tag', classes: ['classname'] })\n\n//test(\"// some text\", { type: 'comment', state: 'TEXT_START' })\ntest(\"// some text\", { type: 'comment', state: 'TEXT_START', val: ' some text' })\n\n// test(\"// \", { type: 'comment', state: 'TEXT_START' })\ntest(\"// \", { type: 'comment', val: ' ', state: 'TEXT_START' })\n\ntest(\"//\", { type: 'comment', state: 'TEXT_START' })\n\n\ntest('a.url.fn.n(href=\\'https://wordpress.adamkoch.com/author/admin/\\' title=\\'View all posts by Adam\\' rel=\\'author\\') Adam',  {\n  name: 'a',\n  type: 'tag',\n  classes: [ 'url', 'fn', 'n' ],\n  attrs: [\n    {\n      name: 'href',\n      val: \"'https://wordpress.adamkoch.com/author/admin/'\"\n    },\n    { name: 'title', val: \"'View all posts by Adam'\" },\n    { name: 'rel', val: \"'author'\" }\n  ],\n  val: 'Adam'\n})\ntest('style(id=\\'wp-block-library-inline-css\\' type=\\'text/css\\').', {\n  name: 'style',\n  type: 'tag',\n  attrs: [\n    { name: 'id', val: \"'wp-block-library-inline-css'\" },\n    { name: 'type', val: \"'text/css'\" }\n  ],\n  state: 'TEXT_START'\n})\ntest('| #start-resizable-editor-section{figcaption{color:hsla(0,0%,100%,.65)}', {\"type\":\"text\",\"val\":\"#start-resizable-editor-section{figcaption{color:hsla(0,0%,100%,.65)}\"})\ntest('body.post-template-default.single.single-post.postid-1620.single-format-standard.wp-embed-responsive.single-author.singular.two-column.right-sidebar', {\"type\":\"tag\",\"name\":\"body\",\"classes\":[\"post-template-default\",\"single\",\"single-post\",\"postid-1620\",\"single-format-standard\",\"wp-embed-responsive\",\"single-author\",\"singular\",\"two-column\",\"right-sidebar\"]})\ntest('#page.hfeed', {\"type\":\"tag\",\"id\":\"page\",\"classes\":[\"hfeed\"]})\ntest('header#branding(role=\\'banner\\')', {\n  name: 'header',\n  type: 'tag',\n  id: 'branding',\n  attrs: [ { name: 'role', val: \"'banner'\" } ]\n})\ntest('h1#site-title', {type: 'tag', name: 'h1', id: 'site-title'})\ntest('a(href=\\'https://www.adamkoch.com/\\' rel=\\'home\\') Adam Koch', {\n  name: 'a',\n  type: 'tag',\n  attrs: [\n    { name: 'href', val: \"'https://www.adamkoch.com/'\" },\n    { name: 'rel', val: \"'home'\" }\n  ],\n  val: 'Adam Koch'\n})\ntest('h2#site-description Software Developer and Clean Code Advocate', {type: 'tag', name: 'h2', id: 'site-description', val: 'Software Developer and Clean Code Advocate' })\ntest('h3.assistive-text Main menu', {type: 'tag', name: 'h3', classes: ['assistive-text'], val: 'Main menu' })\ntest('ul#menu-header.menu', {type: 'tag', name: 'ul', id: 'menu-header', classes: ['menu']})\ntest('a(href=\\'https://wordpress.adamkoch.com/posts/\\') Posts', {\n  name: 'a',\n  type: 'tag',\n  attrs: [ { name: 'href', val: \"'https://wordpress.adamkoch.com/posts/'\" } ],\n  val: 'Posts'\n})\ntest('span.sep  by', {type:'tag', name: 'span', classes: ['sep'], val: ' by' })\ntest('style.', {\"type\":\"tag\",\"name\":\"style\",\"state\":\"TEXT_START\"})\ntest('p I came across a problem in Internet Explorer (it wasn\\'t a problem with Firefox) when I was trying to compare two strings. To me, one string looked to have an extra space in the front. No problem, I\\'ll just call the', {\n  type: 'tag',\n  name: 'p',\n  val: \"I came across a problem in Internet Explorer (it wasn't a problem with Firefox) when I was trying to compare two strings. To me, one string looked to have an extra space in the front. No problem, I'll just call the\"\n})\ntest('.sd-content', { type: 'tag', classes: [ 'sd-content' ] })\ntest('th  Browser', { type: 'tag', name: 'th', val: ' Browser' })\ntest('.sharedaddy.sd-sharing-enabled', {\"type\":\"tag\",\"classes\":['sharedaddy', 'sd-sharing-enabled']})\ntest('time(datetime=\\'2009-07-28T01:24:04-06:00\\') 2009-07-28 at 1:24 AM', {\n  name: 'time',\n  type: 'tag',\n  attrs: [ { name: 'datetime', val: \"'2009-07-28T01:24:04-06:00'\" } ],\n  val: '2009-07-28 at 1:24 AM'\n} )\ntest('- var title = \\'Fade Out On MouseOver Demo\\'', { type: 'code', val: 'var title = \\'Fade Out On MouseOver Demo\\'', state: 'CODE_START' })\ntest('<TEXT>}).join(\\' \\')', { type: 'text', val: \"}).join(' ')\" })\ntest('  ', {\n  type: 'empty'\n})\ntest('#content(role=\\'main\\')', {\n  type: 'tag',\n  id: 'content',\n  attrs: [ { name: 'role', val: \"'main'\" } ]\n})\ntest('pre: code(class=\"language-scss\").', {\n  name: 'pre',\n  type: 'tag',\n  state: 'NESTED',\n  children: [\n    { name: 'code', type: 'tag', attrs: [\n        {\n          name: 'class',\n          val: '\"language-scss\"'\n        }], state: 'TEXT_START' }\n  ]\n})\n\ntest('mixin sensitive()', { type: 'mixin', val: 'sensitive()' })\ntest('extends ../templates/blogpost', {\n  type: 'extends',\n  val: '../templates/blogpost'\n})\ntest('append head', {\n  type: 'append',\n  val: 'head'\n})\ntest('p Maecenas sed lorem accumsan, luctus eros eu, tempor dolor. Vestibulum lorem est, bibendum vel vulputate eget, vehicula eu elit. Donec interdum cursus felis, vitae posuere libero. Cras et lobortis velit. Pellentesque in imperdiet justo. Suspendisse dolor mi, aliquet at luctus a, suscipit quis lectus. Etiam dapibus venenatis sem, quis aliquam nisl volutpat vel. Aenean scelerisque dapibus sodales. Vestibulum in pretium diam. Quisque et urna orci.', {type: 'tag', name: 'p', val: 'Maecenas sed lorem accumsan, luctus eros eu, tempor dolor. Vestibulum lorem est, bibendum vel vulputate eget, vehicula eu elit. Donec interdum cursus felis, vitae posuere libero. Cras et lobortis velit. Pellentesque in imperdiet justo. Suspendisse dolor mi, aliquet at luctus a, suscipit quis lectus. Etiam dapibus venenatis sem, quis aliquam nisl volutpat vel. Aenean scelerisque dapibus sodales. Vestibulum in pretium diam. Quisque et urna orci.' })\n\ntest('+project(\\'Images\\', \\'On going\\')', { type: 'mixin_call', name: 'project', params: \"'Images', 'On going'\" })\ntest(\"+project('Moddable Two (2) Case', 'Needing Documentation ', ['print'])\", {\n  type: 'mixin_call',\n  name: 'project',\n  params: \"'Moddable Two (2) Case', 'Needing Documentation ', ['print']\"\n})\ntest('| . The only \"gotcha\" was I originally had \"www.adamkoch.com\" as the A record instead of \"adamkoch.com\". Not a big deal and easy to rectify.', { type: 'text', val: '. The only \"gotcha\" was I originally had \"www.adamkoch.com\" as the A record instead of \"adamkoch.com\". Not a big deal and easy to rectify.' })\ntest('<TEXT>| #start-resizable-editor-section{display:none}.wp-block-audio figcaption{color:#555;font-size:13px;', {\"type\":\"text\",\"val\":\"#start-resizable-editor-section{display:none}.wp-block-audio figcaption{color:#555;font-size:13px;\" })\n\n// test('- ', { type: 'code', val: ' ', state: 'UNBUF_CODE_START' })\ntest('- ', { type: 'code', state: 'CODE_START' })\n\ntest('mixin project(title)', {\n  type: 'mixin',\n  val: 'project(title)'\n})\ntest('// comment', {\n  state: 'TEXT_START',\n  type: 'comment',\n  val: ' comment'\n})\ntest('meta(property=\\'og:description\\' content=\\'I came across a problem in Internet Explorer (it wasn\\\\\\'t a problem with Firefox) when I...\\')',  {\n  name: 'meta',\n  type: 'tag',\n  attrs: [\n    { name: 'property', val: \"'og:description'\" },\n    {\n      name: 'content',\n      val: \"'I came across a problem in Internet Explorer (it wasn\\\\'t a problem with Firefox) when I...'\"\n    }\n  ]\n})\n\ntest('-', {\n  type: 'code',\n  state: 'CODE_START'\n})\n\n// test(' -', {\n//   state: 'UNBUF_CODE_START',\n//   type: 'code',\n//   val: ''\n// })\n\ntest('<UNBUF_CODE>var i', {\n  type: 'code',\n  val: 'var i'\n})\n\ntest(\"link(rel='alternate' type='application/rss+xml' title='Adam Koch &raquo; White-space and character 160 Comments Feed' href='https://wordpress.adamkoch.com/2009/07/25/white-space-and-character-160/feed/')\",  {\n  name: 'link',\n  type: 'tag',\n  attrs: [\n    { name: 'rel', val: \"'alternate'\" },\n    { name: 'type', val: \"'application/rss+xml'\" },\n    {\n      name: 'title',\n      val: \"'Adam Koch &raquo; White-space and character 160 Comments Feed'\"\n    },\n    {\n      name: 'href',\n      val: \"'https://wordpress.adamkoch.com/2009/07/25/white-space-and-character-160/feed/'\"\n    }\n  ]\n})\n\ntest('pre.', {\n  name: 'pre',\n  state: 'TEXT_START',\n  type: 'tag'\n})\n\ntest('pre: code.', {\n  children: [\n    {\n      name: 'code',\n      state: 'TEXT_START',\n      type: 'tag'\n    }\n  ],\n  name: 'pre',\n  state: 'NESTED',\n  type: 'tag'\n})\n\ntest('|. The only \"gotcha\" was I originally had \"www.adamkoch.com\" as the A record instead of \"adamkoch.com\". Not a big deal and easy to rectify.', { type: 'text', val: '. The only \"gotcha\" was I originally had \"www.adamkoch.com\" as the A record instead of \"adamkoch.com\". Not a big deal and easy to rectify.' })\n\ntest('.rule: p.', {\n  children: [\n    {\n      name: 'p',\n      type: 'tag',\n      state: 'TEXT_START'\n    }\n  ],\n  classes: ['rule'],\n  state: 'NESTED',\n  type: 'tag'\n})\ntest('.rule.unratified: p.', {\n  children: [\n    {\n      name: 'p',\n      type: 'tag',\n      state: 'TEXT_START'\n    }\n  ],\n  classes: ['rule', 'unratified'],\n  state: 'NESTED',\n  type: 'tag'\n})\n\ntest(\"style(id='wp-block-library-inline-css' type='text/css'). \", {\n  name: 'style',\n  type: 'tag',\n  attrs: [\n    { name: 'id', val: \"'wp-block-library-inline-css'\" },\n    { name: 'type', val: \"'text/css'\" }\n  ],\n  state: 'TEXT_START'\n})\n\ntest('|', {\n  type: 'empty'\n})\ntest('.', { state: 'TEXT_START' })\n\ntry {\n  test(\"tag\", { type: 'unknown', name: 'tag' })\nthrow AssertionError('Expected exception')\n} catch (e) {}\n// }\n\n\ntest('+code(\\'Pretty-print any JSON file\\') jq \\'.\\' package.json',\n{\n  type: 'mixin_call',\n  name: 'code',\n  params: \"'Pretty-print any JSON file'\",\n  val: \"jq '.' package.json\"\n} )\n\ntest(\"a(href='/save').button save\", {\n  name: 'a',\n  type: 'tag',\n  attrs: [ { name: 'href', val: \"'/save'\" } ],\n  classes: 'button',\n  val: 'save'\n})\n\ntest(\"meta( charset='utf8' )\", {\n  name: 'meta',\n  type: 'tag',\n  attrs: [ { name: 'charset', val: \"'utf8'\" } ]\n})\n\n// test(\"input(pattern='\\\\\\\\S+')\", {})\ntest(\"a(href='/contact') contact\", {\n  name: 'a',\n  type: 'tag',\n  attrs: [ { name: 'href', val: \"'/contact'\" } ],\n  val: 'contact'\n})\ntest(\"a(foo bar baz)\", {\n  name: 'a',\n  type: 'tag',\n  attrs: [ { name: 'foo' }, { name: 'bar' }, { name: 'baz' } ]\n})\ntest(\"a(foo='foo, bar, baz' bar=1)\", {\n  name: 'a',\n  type: 'tag',\n  attrs: [\n    { name: 'foo', val: \"'foo, bar, baz'\" },\n    { name: 'bar', val: '1' }\n  ] \n})\ntest(\"a(foo='((foo))' bar= (1) ? 1 : 0 )\", {\n  name: 'a',\n  type: 'tag',\n  attrs: [\n    { name: 'foo', val: \"'((foo))'\" },\n    { name: 'bar', val: '(1) ? 1 : 0' }\n  ]\n})\ntest(\"select\", { name: 'select', type: 'tag' })\ntest(\"option(value='foo' selected) Foo\",{\n  name: 'option',\n  type: 'tag',\n  attrs: [ { name: 'value', val: \"'foo'\" }, { name: 'selected' } ],\n  val: 'Foo'\n})\ntest(\"option(selected value='bar') Bar\", {\n  name: 'option',\n  type: 'tag',\n  attrs: [ { name: 'selected' }, { name: 'value', val: \"'bar'\" } ],\n  val: 'Bar'\n})\ntest('a(foo=\"class:\")', { name: 'a', type: 'tag', attrs: [ { name: 'foo', val: '\"class:\"' } ] })\n// test(\"input(pattern='\\\\S+')\", {})\ntest('foo(terse=\"true\")', {\n  name: 'foo',\n  type: 'tag',\n  attrs: [ { name: 'terse', val: '\"true\"' } ]\n})\ntest(\"foo(date=new Date(0))\", {\n  name: 'foo',\n  type: 'tag',\n  attrs: [ { name: 'date', val: 'new Date(0)' } ]\n})\ntest(\"- var attrs = {foo: 'bar', bar: '<baz>'}\",  {\n  type: 'code',\n  state: 'CODE_START',\n  val: \"var attrs = {foo: 'bar', bar: '<baz>'}\"\n})\n// test(\"a(foo='foo' \\\"bar\\\"=\\\"bar\\\")\", {})\n\ntry {\n  test(\"a(foo='foo' 'bar'='bar'))\", {})\n  fail('expected exception')\n} catch (expected) {}\n\n// TODO:\ntest(\"div&attributes(attrs)\", { type: 'tag', name: 'div', attrs: [{val: 'attrs'}] })\n\n\ntest('p A sentence with a #[strong strongly worded phrase] that cannot be #[em ignored].', {\n  name: 'p',\n  type: 'tag',\n  children: [\n    { type: 'text', val: 'A sentence with a ' },\n    { type: 'tag', name: 'strong', val: 'strongly worded phrase' },\n    { type: 'text', val: ' that cannot be ' },\n    { type: 'tag', name: 'em', val: 'ignored' },\n    { type: 'text', val: '.' }\n  ]\n})\n\ntest(`p Some text #[a.rho(href='#', class='rho--modifier') with inline link]`, {\n  name: 'p',\n  type: 'tag',\n  children: [\n    { type: 'text', val: 'Some text ' },\n    {\n      name: 'a',\n      type: 'tag',\n      classes: ['rho'],\n      attrs: [{\n          name: 'href',\n          val: \"'#'\"\n        },\n        {\n          name: 'class',\n          val: \"'rho--modifier'\"\n        }],\n      val: 'with inline link'\n    }\n  ]\n})\n\ntest(`p #[a.rho(href='#', class='rho--modifier') with inline link]`, {\n  name: 'p',\n  type: 'tag',\n  children: [\n    {\n      name: 'a',\n      type: 'tag',\n      classes: ['rho'],\n      attrs: [{\n          name: 'href',\n          val: \"'#'\"\n        },\n        {\n          name: 'class',\n          val: \"'rho--modifier'\"\n        }],\n      val: 'with inline link'\n    }\n  ]\n})\n\n};\n\n",
  "ebnf": {
    "start": [
      "EOF",
      "line EOF"
    ],
    "line": [
      "line_start",
      [
        "line_start TEXT",
        "\n    debug('line: line_start TEXT: $line_start=', $line_start, ', $TEXT=', $TEXT)\n\n    // if ($TEXT.includes('#[')) {\n    //   debug('Calling parseInline with ', $TEXT)\n    //   const possibleTags2 = parseInline.parse($TEXT)\n    //   debug('possibleTags2=', possibleTags2)\n    // }\n    // $$ = { type: 'text', val: $TEXT }\n    \n    $$ = merge($line_start, { type: 'text', val: $TEXT })\n  "
      ],
      [
        "line_start CODE",
        "\n    $$ = merge($line_start, { type: 'code', val: $CODE })\n  "
      ],
      [
        "line_start line_splitter line_end",
        "\n    debug('line: line_start line_splitter line_end: $line_start=', $line_start, ', $line_end=', $line_end)\n    if ($line_end == undefined) {\n      $$ = merge($line_start, $line_splitter)\n    }\n    else if ($line_end.hasOwnProperty('type') && $line_end.type == 'array') {\n      $$ = merge($line_start, [$line_splitter, { children: $line_end.val }])\n    }\n    else {\n      $$ = merge($line_start, [$line_splitter, $line_end])\n    }\n  "
      ],
      [
        "line_start NESTED_TAG_START line",
        "\n    $$ = merge($line_start, { state: 'NESTED', children: [$line] })\n  "
      ],
      [
        "ATTR_TEXT_END",
        "\n    $$ = { type: 'attr_end', val: $ATTR_TEXT_END }\n  "
      ],
      [
        "ATTR_TEXT_CONT",
        "\n    $$ = { type: 'attr_cont', val: $ATTR_TEXT_CONT, state: 'MULTI_LINE_ATTRS' }\n  "
      ],
      [
        "line_start AT_ATTRS",
        "\n    debug('line: line_start AT_ATTRS: $AT_ATTRS=', $AT_ATTRS)\n    if ($AT_ATTRS.includes('{') && $AT_ATTRS.includes('}')) {\n      let func = Function('return (' + $AT_ATTRS.substring(12, $AT_ATTRS.length - 1) + ')')\n      let entries2 = Object.entries(func())\n      debug('entries2=', entries2)\n      let attrs2 = Object.entries(entries2).map(([index, [key, value]]) => {\n        debug('key=', key, 'value=', value)\n        return { name: key, val: value }\n      })\n      $$ = merge($line_start, { type: 'tag', attrs: attrs2 })\n    }\n    else {\n      $$ = merge($line_start, \n        { type: 'tag', attrs: [{ val: $AT_ATTRS.substring(12, $AT_ATTRS.length - 1) }]}\n      )\n    }\n  "
      ]
    ],
    "line_start": [
      "first_token",
      [
        "first_token tag_part",
        "\n    debug('line_start: first_token tag_part')\n    $$ = merge($first_token, $tag_part)\n  "
      ],
      [
        "first_token attrs",
        "\n    debug('line_start: first_token attrs')\n    $$ = merge($first_token, $attrs)\n  "
      ],
      [
        "first_token LPAREN ATTR_TEXT_CONT?",
        "\n    debug('line_start: first_token LPAREN ATTR_TEXT_CONT?')\n    $$ = merge($first_token, { state: 'MULTI_LINE_ATTRS' })\n    if ($3) {\n      debug('3 Calling parseAttrs with ', $3)\n      try {\n        $$ = merge($first_token, {  attrs: parseAttrs.parse($3) })\n      }\n      catch (e) {\n        console.error('Could not parse attributes=' +$3, e)\n      }\n    }\n  "
      ],
      [
        "first_token tag_part LPAREN ATTR_TEXT_CONT",
        "\n    debug('line_start: first_token tag_part LPAREN ATTR_TEXT_CONT')\n    $$ = merge($first_token, [$tag_part, $ATTR_TEXT_CONT])\n  "
      ],
      [
        "first_token tag_part attrs",
        "\n    debug('line_start: first_token tag_part attrs')\n    $$ = merge($first_token, [$tag_part, $attrs])\n  "
      ],
      [
        "first_token attrs CLASSNAME",
        "\n    $$ = merge($first_token, [$attrs, { classes: $CLASSNAME }])\n  "
      ],
      [
        "first_token tag_part attrs CLASSNAME",
        "\n    $$ = merge($first_token, [$tag_part, $attrs, { classes: $CLASSNAME }])\n  "
      ],
      [
        "ATTR_TEXT",
        "\n    debug('line_start: ATTR_TEXT')\n    $$ = { type: 'attrs_cont', attrs: [$ATTR_TEXT] }\n  "
      ],
      [
        "first_token LPAREN MIXIN_PARAMS RPAREN",
        "\n    $$ = merge($first_token, { params: $MIXIN_PARAMS })\n  "
      ]
    ],
    "first_token": [
      [
        "TAG",
        "\n    $$ = { name: $TAG, type: 'tag' }\n  "
      ],
      [
        "TEXT_TAG",
        "\n    $$ = { name: $TEXT_TAG, type: 'tag', state: 'TEXT_START' }\n  "
      ],
      [
        "CLASSNAME",
        "\n    $$ = { type: 'tag', classes: [$1] }\n  "
      ],
      [
        "TAG_ID",
        "\n    $$ = { type: 'tag', id: $TAG_ID }\n  "
      ],
      [
        "TEXT",
        "\n    // if ($TEXT.includes('#[')) {\n    //   debug('Calling parseInline with ', $TEXT)\n    //   const possibleTags = parseInline.parse($TEXT)\n    //   debug('possibleTags=', possibleTags)\n    // }\n    $$ = { type: 'text', val: $TEXT }\n  "
      ],
      [
        "COMMENT",
        "\n    $$ = { type: 'comment', state: 'TEXT_START' }\n  "
      ],
      [
        "CODE_START",
        "\n    debug('CODE_START')\n    $$ = { type: 'code', state: 'CODE_START' }\n  "
      ],
      [
        "CODE",
        "\n    $$ = { type: 'code', val: $CODE }\n  "
      ],
      [
        "MIXIN_CALL",
        "\n    debug('MIXIN_CALL=', $1)\n    $$ = { type: 'mixin_call', name: $1 }\n  "
      ],
      [
        "KEYWORD",
        "\n    $$ = { type: $KEYWORD }\n  "
      ],
      [
        "PIPE",
        "\n    $$ = { type: 'text' }\n  "
      ],
      [
        "RCURLY",
        "\n    $$ = { type: 'block_end' }\n  "
      ],
      [
        "DOT_END",
        "\n    debug('line: DOT_END')\n    $$ = { state: 'TEXT_START' }\n  "
      ],
      [
        "SPACE",
        "\n    $$ = { type: 'empty' }\n  "
      ],
      [
        "CONDITIONAL",
        "\n    $$ = { type: 'conditional', name: $CONDITIONAL }\n  "
      ],
      [
        "INTERPOLATION",
        "\n    $$ = { type: 'interpolation', name: $INTERPOLATION }\n  "
      ],
      [
        "INTERPOLATION_START",
        "\n    $$ = { type: 'interpolation_start', state: 'INTERPOLATION_START' }\n  "
      ]
    ],
    "tag_part": [
      [
        "TAG_ID",
        "\n    $$ = { id: $TAG_ID }\n  "
      ],
      [
        "TAG_ID classnames",
        "\n    $$ = merge({ id: $TAG_ID }, $classnames)\n  "
      ],
      "classnames",
      [
        "classnames TAG_ID",
        "\n    $$ = merge({ id: $TAG_ID }, $classnames)\n  "
      ],
      [
        "FILTER",
        "\n    $$ = { filter: $FILTER }\n  "
      ]
    ],
    "attrs": [
      [
        "LPAREN ATTR_TEXT RPAREN",
        "\n    debug('1 Calling parseAttrs with ', $2)\n    $$ = {}\n    try {\n      const attrs = parseAttrs.parse($2.trim())\n      debug('attrs=', attrs)\n      attrs.forEach(attr => {\n        // if (attr.hasOwnProperty('key') && attr.key == 'class' && !attr.assignment) {\n        //   $$ = merge($$, { classes: attr.val.split(' ') } )\n        //   delete attr.class\n        // }\n        // else if (attr.hasOwnProperty('id')) {\n        //   $$ = merge($$, { id: attr.id } )\n        //   delete attr.id\n        // }\n        // else \n        if (!_.isEmpty(attr)) {\n          $$ = merge($$, { attrs: [attr] })\n        }\n      })\n    } catch (e) {\n      console.error('Error parsing ' + $2, e)\n    }\n  "
      ],
      [
        "LPAREN CONDITION RPAREN",
        "\n    debug('attrs: LPAREN CONDITION RPAREN')\n    $$ = { condition: $2 }\n  "
      ]
    ],
    "classnames": [
      [
        "CLASSNAME+",
        "\n    $$ = { type: 'tag', classes: $1 }\n  "
      ]
    ],
    "line_end": [
      [
        "",
        "\n    debug('line_end: <blank>')\n  "
      ],
      [
        "DOT_END",
        "\n    debug('line_end: DOT_END')\n    $$ = { state: 'TEXT_START' }\n  "
      ],
      [
        "ASSIGNMENT_VALUE",
        "\n    $$ = { assignment_val: $ASSIGNMENT_VALUE }\n  "
      ],
      [
        "ATTR_TEXT_CONT",
        "\n    debug('line_end: ATTR_TEXT_CONT')\n    $$ = { attrscont: [$1] }\n  "
      ],
      [
        "TEXT",
        "\n    debug('line_end: TEXT: $TEXT=', $TEXT)\n    if ($TEXT.includes('#[')) {\n\n      const matches1 = $TEXT.matchAll(/#\\[.*?\\]/g)\n      debug('matches1', matches1)\n      let idx = 0\n      let elems = []\n      for (const match of matches1) {\n        if (idx != match.index) {\n          elems.push({ type: 'text', val: $TEXT.substring(idx, match.index) })\n          idx = match.index\n        }\n        elems.push(this.yy.parser.parse(match[0].slice(2, -1)))\n        idx += match[0].length\n        // debug('match', match)\n        // console.log(`Found ${match[0]} start=${match.index} end=${match.index + match[0].length}.`);\n      }\n      if (idx != $TEXT.length) {\n        elems.push({ type: 'text', val: $TEXT.substring(idx, $TEXT.index) })\n      }\n      debug('elems', elems)\n      $$ = { children: elems }\n    }\n    else {\n      $$ = { type: 'text', val: $TEXT }\n    }\n  "
      ],
      [
        "CODE",
        "\n    $$ = { type: 'code', val: $CODE }\n  "
      ],
      [
        "RPAREN",
        "\n    $$ = { type: 'text', val: $RPAREN }\n  "
      ]
    ],
    "line_splitter": [
      [
        "SPACE",
        "\n    debug('line_splitter: SPACE')\n    $$ = {}\n  "
      ],
      [
        "ASSIGNMENT",
        "\n    $$ = { assignment: true }\n  "
      ],
      [
        "DOT_END",
        "\n    debug('line_splitter: DOT_END')\n    $$ = { state: 'TEXT_START' }\n  "
      ]
    ]
  },
  "bnf": {
    "start": [
      "EOF",
      "line EOF"
    ],
    "line": [
      "line_start",
      [
        "line_start TEXT",
        "\n    debug('line: line_start TEXT: $line_start=', $line_start, ', $TEXT=', $TEXT)\n\n    // if ($TEXT.includes('#[')) {\n    //   debug('Calling parseInline with ', $TEXT)\n    //   const possibleTags2 = parseInline.parse($TEXT)\n    //   debug('possibleTags2=', possibleTags2)\n    // }\n    // $$ = { type: 'text', val: $TEXT }\n    \n    $$ = merge($line_start, { type: 'text', val: $TEXT })\n  "
      ],
      [
        "line_start CODE",
        "\n    $$ = merge($line_start, { type: 'code', val: $CODE })\n  "
      ],
      [
        "line_start line_splitter line_end",
        "\n    debug('line: line_start line_splitter line_end: $line_start=', $line_start, ', $line_end=', $line_end)\n    if ($line_end == undefined) {\n      $$ = merge($line_start, $line_splitter)\n    }\n    else if ($line_end.hasOwnProperty('type') && $line_end.type == 'array') {\n      $$ = merge($line_start, [$line_splitter, { children: $line_end.val }])\n    }\n    else {\n      $$ = merge($line_start, [$line_splitter, $line_end])\n    }\n  "
      ],
      [
        "line_start NESTED_TAG_START line",
        "\n    $$ = merge($line_start, { state: 'NESTED', children: [$line] })\n  "
      ],
      [
        "ATTR_TEXT_END",
        "\n    $$ = { type: 'attr_end', val: $ATTR_TEXT_END }\n  "
      ],
      [
        "ATTR_TEXT_CONT",
        "\n    $$ = { type: 'attr_cont', val: $ATTR_TEXT_CONT, state: 'MULTI_LINE_ATTRS' }\n  "
      ],
      [
        "line_start AT_ATTRS",
        "\n    debug('line: line_start AT_ATTRS: $AT_ATTRS=', $AT_ATTRS)\n    if ($AT_ATTRS.includes('{') && $AT_ATTRS.includes('}')) {\n      let func = Function('return (' + $AT_ATTRS.substring(12, $AT_ATTRS.length - 1) + ')')\n      let entries2 = Object.entries(func())\n      debug('entries2=', entries2)\n      let attrs2 = Object.entries(entries2).map(([index, [key, value]]) => {\n        debug('key=', key, 'value=', value)\n        return { name: key, val: value }\n      })\n      $$ = merge($line_start, { type: 'tag', attrs: attrs2 })\n    }\n    else {\n      $$ = merge($line_start, \n        { type: 'tag', attrs: [{ val: $AT_ATTRS.substring(12, $AT_ATTRS.length - 1) }]}\n      )\n    }\n  "
      ]
    ],
    "line_start": [
      "first_token",
      [
        "first_token tag_part",
        "\n    debug('line_start: first_token tag_part')\n    $$ = merge($first_token, $tag_part)\n  "
      ],
      [
        "first_token attrs",
        "\n    debug('line_start: first_token attrs')\n    $$ = merge($first_token, $attrs)\n  "
      ],
      [
        "first_token LPAREN line_start_option",
        "\n    debug('line_start: first_token LPAREN ATTR_TEXT_CONT?')\n    $$ = merge($first_token, { state: 'MULTI_LINE_ATTRS' })\n    if ($3) {\n      debug('3 Calling parseAttrs with ', $3)\n      try {\n        $$ = merge($first_token, {  attrs: parseAttrs.parse($3) })\n      }\n      catch (e) {\n        console.error('Could not parse attributes=' +$3, e)\n      }\n    }\n  "
      ],
      [
        "first_token tag_part LPAREN ATTR_TEXT_CONT",
        "\n    debug('line_start: first_token tag_part LPAREN ATTR_TEXT_CONT')\n    $$ = merge($first_token, [$tag_part, $ATTR_TEXT_CONT])\n  "
      ],
      [
        "first_token tag_part attrs",
        "\n    debug('line_start: first_token tag_part attrs')\n    $$ = merge($first_token, [$tag_part, $attrs])\n  "
      ],
      [
        "first_token attrs CLASSNAME",
        "\n    $$ = merge($first_token, [$attrs, { classes: $CLASSNAME }])\n  "
      ],
      [
        "first_token tag_part attrs CLASSNAME",
        "\n    $$ = merge($first_token, [$tag_part, $attrs, { classes: $CLASSNAME }])\n  "
      ],
      [
        "ATTR_TEXT",
        "\n    debug('line_start: ATTR_TEXT')\n    $$ = { type: 'attrs_cont', attrs: [$ATTR_TEXT] }\n  "
      ],
      [
        "first_token LPAREN MIXIN_PARAMS RPAREN",
        "\n    $$ = merge($first_token, { params: $MIXIN_PARAMS })\n  "
      ]
    ],
    "first_token": [
      [
        "TAG",
        "\n    $$ = { name: $TAG, type: 'tag' }\n  "
      ],
      [
        "TEXT_TAG",
        "\n    $$ = { name: $TEXT_TAG, type: 'tag', state: 'TEXT_START' }\n  "
      ],
      [
        "CLASSNAME",
        "\n    $$ = { type: 'tag', classes: [$1] }\n  "
      ],
      [
        "TAG_ID",
        "\n    $$ = { type: 'tag', id: $TAG_ID }\n  "
      ],
      [
        "TEXT",
        "\n    // if ($TEXT.includes('#[')) {\n    //   debug('Calling parseInline with ', $TEXT)\n    //   const possibleTags = parseInline.parse($TEXT)\n    //   debug('possibleTags=', possibleTags)\n    // }\n    $$ = { type: 'text', val: $TEXT }\n  "
      ],
      [
        "COMMENT",
        "\n    $$ = { type: 'comment', state: 'TEXT_START' }\n  "
      ],
      [
        "CODE_START",
        "\n    debug('CODE_START')\n    $$ = { type: 'code', state: 'CODE_START' }\n  "
      ],
      [
        "CODE",
        "\n    $$ = { type: 'code', val: $CODE }\n  "
      ],
      [
        "MIXIN_CALL",
        "\n    debug('MIXIN_CALL=', $1)\n    $$ = { type: 'mixin_call', name: $1 }\n  "
      ],
      [
        "KEYWORD",
        "\n    $$ = { type: $KEYWORD }\n  "
      ],
      [
        "PIPE",
        "\n    $$ = { type: 'text' }\n  "
      ],
      [
        "RCURLY",
        "\n    $$ = { type: 'block_end' }\n  "
      ],
      [
        "DOT_END",
        "\n    debug('line: DOT_END')\n    $$ = { state: 'TEXT_START' }\n  "
      ],
      [
        "SPACE",
        "\n    $$ = { type: 'empty' }\n  "
      ],
      [
        "CONDITIONAL",
        "\n    $$ = { type: 'conditional', name: $CONDITIONAL }\n  "
      ],
      [
        "INTERPOLATION",
        "\n    $$ = { type: 'interpolation', name: $INTERPOLATION }\n  "
      ],
      [
        "INTERPOLATION_START",
        "\n    $$ = { type: 'interpolation_start', state: 'INTERPOLATION_START' }\n  "
      ]
    ],
    "tag_part": [
      [
        "TAG_ID",
        "\n    $$ = { id: $TAG_ID }\n  "
      ],
      [
        "TAG_ID classnames",
        "\n    $$ = merge({ id: $TAG_ID }, $classnames)\n  "
      ],
      "classnames",
      [
        "classnames TAG_ID",
        "\n    $$ = merge({ id: $TAG_ID }, $classnames)\n  "
      ],
      [
        "FILTER",
        "\n    $$ = { filter: $FILTER }\n  "
      ]
    ],
    "attrs": [
      [
        "LPAREN ATTR_TEXT RPAREN",
        "\n    debug('1 Calling parseAttrs with ', $2)\n    $$ = {}\n    try {\n      const attrs = parseAttrs.parse($2.trim())\n      debug('attrs=', attrs)\n      attrs.forEach(attr => {\n        // if (attr.hasOwnProperty('key') && attr.key == 'class' && !attr.assignment) {\n        //   $$ = merge($$, { classes: attr.val.split(' ') } )\n        //   delete attr.class\n        // }\n        // else if (attr.hasOwnProperty('id')) {\n        //   $$ = merge($$, { id: attr.id } )\n        //   delete attr.id\n        // }\n        // else \n        if (!_.isEmpty(attr)) {\n          $$ = merge($$, { attrs: [attr] })\n        }\n      })\n    } catch (e) {\n      console.error('Error parsing ' + $2, e)\n    }\n  "
      ],
      [
        "LPAREN CONDITION RPAREN",
        "\n    debug('attrs: LPAREN CONDITION RPAREN')\n    $$ = { condition: $2 }\n  "
      ]
    ],
    "classnames": [
      [
        "classnames_repetition_plus",
        "\n    $$ = { type: 'tag', classes: $1 }\n  "
      ]
    ],
    "line_end": [
      [
        "",
        "\n    debug('line_end: <blank>')\n  "
      ],
      [
        "DOT_END",
        "\n    debug('line_end: DOT_END')\n    $$ = { state: 'TEXT_START' }\n  "
      ],
      [
        "ASSIGNMENT_VALUE",
        "\n    $$ = { assignment_val: $ASSIGNMENT_VALUE }\n  "
      ],
      [
        "ATTR_TEXT_CONT",
        "\n    debug('line_end: ATTR_TEXT_CONT')\n    $$ = { attrscont: [$1] }\n  "
      ],
      [
        "TEXT",
        "\n    debug('line_end: TEXT: $TEXT=', $TEXT)\n    if ($TEXT.includes('#[')) {\n\n      const matches1 = $TEXT.matchAll(/#\\[.*?\\]/g)\n      debug('matches1', matches1)\n      let idx = 0\n      let elems = []\n      for (const match of matches1) {\n        if (idx != match.index) {\n          elems.push({ type: 'text', val: $TEXT.substring(idx, match.index) })\n          idx = match.index\n        }\n        elems.push(this.yy.parser.parse(match[0].slice(2, -1)))\n        idx += match[0].length\n        // debug('match', match)\n        // console.log(`Found ${match[0]} start=${match.index} end=${match.index + match[0].length}.`);\n      }\n      if (idx != $TEXT.length) {\n        elems.push({ type: 'text', val: $TEXT.substring(idx, $TEXT.index) })\n      }\n      debug('elems', elems)\n      $$ = { children: elems }\n    }\n    else {\n      $$ = { type: 'text', val: $TEXT }\n    }\n  "
      ],
      [
        "CODE",
        "\n    $$ = { type: 'code', val: $CODE }\n  "
      ],
      [
        "RPAREN",
        "\n    $$ = { type: 'text', val: $RPAREN }\n  "
      ]
    ],
    "line_splitter": [
      [
        "SPACE",
        "\n    debug('line_splitter: SPACE')\n    $$ = {}\n  "
      ],
      [
        "ASSIGNMENT",
        "\n    $$ = { assignment: true }\n  "
      ],
      [
        "DOT_END",
        "\n    debug('line_splitter: DOT_END')\n    $$ = { state: 'TEXT_START' }\n  "
      ]
    ],
    "line_start_option": [
      [
        "",
        "$$ = undefined;"
      ],
      [
        "ATTR_TEXT_CONT",
        "$$ = $1;"
      ]
    ],
    "classnames_repetition_plus": [
      [
        "CLASSNAME",
        "$$ = [$1];"
      ],
      [
        "classnames_repetition_plus CLASSNAME",
        "$1.push($2);\n$$ = $1;"
      ]
    ]
  }
}