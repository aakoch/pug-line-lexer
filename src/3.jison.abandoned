/* simple parser */

/* lexical grammar */
%lex

word         [a-zA-Z]+
number       [0-9]+
space			[\t \u00a0\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u2028\u2029\u3000]
other        [^a-zA-Z0-9\s]+ // must put it as "not", but I don't know why

%%

{word}       return 'WORD';
{number}     return 'NUMBER';
// {other}      return 'OTHER';
// {space}      return 'SPACE';
// {indent}     return 'INDENT';
<<EOF>>      return 'ENDOFFILE';
<INITIAL>\s*<<EOF>>		%{
  console.log("remaining DEDENTs", _iemitstack)
					// remaining DEDENTs implied by EOF, regardless of tabs/spaces
					var tokens = [];
				
					while (0 < _iemitstack[0]) {
						this.popState();
						tokens.unshift("DEDENT");
						_iemitstack.shift();
					}
				    
					if (tokens.length) return tokens;
				%}

<INITIAL>[\n\r]{space}*		%{
					var indentation = yyleng - yytext.search(/\s/) - 1;
					if (indentation > _iemitstack[0]) {
						_iemitstack.unshift(indentation);
  console.log("indenting", _iemitstack)
  console.log("yyleng=%s", yyleng)
						return 'INDENT';
					}
				
					var tokens = [];
				
					while (indentation < _iemitstack[0]) {
						this.popState();
						tokens.unshift("DEDENT");
						_iemitstack.shift();
					}
  console.log("dedenting", tokens)
					if (tokens.length) return tokens;
				%}
\n           ; // ignore newlines

/lex

%% 

/* language grammar */

start
  : ENDOFFILE
  { console.log("empty string"); $$ = [] }
  | list ENDOFFILE
  { console.log("list ENDOFFILE", $1); $list = [] }
  ;

list
  : list line
  { console.log("list line=%s", $line); $list.push($line); $$ = $list; }
  | line
  { console.log("line=%s", $line); $$ = [$line]; }
  ;

line
  : INDENT line
  { console.log("INDENT"); $$ = [$line] }
  | token
  { console.log("token=%s", $token); }
  ;

token
  : WORD
  { console.log("WORD=%s", $$); }
  | NUMBER 
  { console.log("NUMBER=%s", $$); $$ = parseInt($$) }
  | OTHER
  | SPACE
  { console.log("SPACE=%s", $$); }
  | DEDENT
  ;

%% 

var _iemitstack = [0]

// feature of the GH fork: specify your own main.
//
// compile with
// 
//      jison -o test.js --main path/to/simple.jison
//
// then run
//
//      node ./test.js
//
// to see the output.

var assert = require("assert");

parser.main = function () {

  function test(input, expected) {
    console.log(`\nTesting '${input}'...`)
    var actual = parser.parse(input)
    console.log(input + ' ==> ', JSON.stringify(actual))
    assert.deepEqual(actual, expected)
  }

  // test('', [])

  // test('abc', [ 'abc' ])

  // test('123', [123])

  // test('abc 123', ['abc',' ', 123])

  // test('!@#$%^&*()_+-=[]\;\',./<>?:"{}|', [`!@#$%^&*()_+-=[];',./<>?:"{}|`])

  // test("abc\n123", ['abc', '\n', 123])

  test(
`html
  head
  body
  
`, ['html', ['head', 'body']])

};
